- arguments:
  - -XTypeApplications # TypeApplications are disabled by default in HLint,
                       # although the documentation says otherwise

# There's no 'head' in Universum
- ignore: {name: "Use head"}

# We have 'whenJust' for this
- ignore: {name: "Use Foldable.forM_"}

############################################################################
## Universum
############################################################################

- warn: {lhs: Data.Text.pack, rhs: toText}
- warn: {lhs: Data.Text.unpack, rhs: toString}

- warn: {lhs: Data.Text.Lazy.pack, rhs: toLText}
- warn: {lhs: Data.Text.Lazy.unpack, rhs: toString}
- warn: {lhs: Data.Text.Lazy.toStrict, rhs: toText}
- warn: {lhs: Data.Text.Lazy.fromStrict, rhs: toLText}

- warn: {lhs: Data.Text.pack (show x), rhs: show x}
- warn: {lhs: Data.Text.Lazy.pack (show x), rhs: show x}

- warn: {lhs: Control.Exception.evaluate, rhs: evaluateWHNF}
- warn: {lhs: Control.Exception.evaluate (force x), rhs: evaluateNF x}
- warn: {lhs: Control.Exception.evaluate (x `deepseq` ()), rhs: evaluateNF_ x}
- warn: {lhs: void (evaluateWHNF x), rhs: evaluateWHNF_ x}
- warn: {lhs: void (evaluateNF x), rhs: evaluateNF_ x}

## Monad.Trans

- warn: {lhs: flip runReaderT , rhs: usingReaderT }
- warn: {lhs: flip runReader  , rhs: usingReader }
- warn: {lhs: flip runStateT  , rhs: usingStateT }
- warn: {lhs: flip runState   , rhs: usingState }
- hint: {lhs: fst <$> usingStateT s st, rhs: evaluatingStateT s st}
- hint: {lhs: fst (usingState s st), rhs: evaluatingState s st}
- hint: {lhs: snd <$> usingStateT s st, rhs: executingStateT s st}
- hint: {lhs: snd (usingState s st), rhs: executingState s st}

## Containers
- hint: {lhs: Data.HashMap.Lazy.keys, rhs: keys}
- hint: {lhs: Data.HashMap.Strict.keys, rhs: keys}
- hint: {lhs: Data.Map.Lazy.keys, rhs: keys}
- hint: {lhs: Data.Map.Strict.keys, rhs: keys}
- hint: {lhs: Data.IntMap.Lazy.keys, rhs: keys}
- hint: {lhs: Data.IntMap.Strict.keys, rhs: keys}

- hint: {lhs: Data.HashMap.Lazy.elems, rhs: elems}
- hint: {lhs: Data.HashMap.Strict.elems, rhs: elems}
- hint: {lhs: Data.Map.Lazy.elems, rhs: elems}
- hint: {lhs: Data.Map.Strict.elems, rhs: elems}
- hint: {lhs: Data.IntMap.Lazy.elems, rhs: elems}
- hint: {lhs: Data.IntMap.Strict.elems, rhs: elems}

- hint: {lhs: Data.HashMap.Lazy.toList, rhs: toPairs}
- hint: {lhs: Data.HashMap.Strict.toList, rhs: toPairs}
- hint: {lhs: Data.Map.Lazy.toList, rhs: toPairs}
- hint: {lhs: Data.Map.Lazy.assocs, rhs: toPairs}
- hint: {lhs: Data.Map.Strict.toList, rhs: toPairs}
- hint: {lhs: Data.Map.Strict.assocs, rhs: toPairs}
- hint: {lhs: Data.IntMap.Lazy.toList, rhs: toPairs}
- hint: {lhs: Data.IntMap.Lazy.assocs, rhs: toPairs}
- hint: {lhs: Data.IntMap.Strict.toList, rhs: toPairs}
- hint: {lhs: Data.IntMap.Strict.assocs, rhs: toPairs}

- warn: { lhs: Data.Map.toAscList (Data.Map.fromList x)
        , rhs: sortWith fst x
        }
- warn: { lhs: Data.Map.toDescList (Data.Map.fromList x)
        , rhs: sortWith (Down . fst) x
        }

- warn: {lhs: Data.Set.toList (Data.Set.fromList l), rhs: sortNub l}
- warn: {lhs: Data.Set.assocs (Data.Set.fromList l), rhs: sortNub l}
- warn: {lhs: Data.Set.toAscList (Data.Set.fromList l), rhs: sortNub l}

- warn: {lhs: Data.HashSet.toList (Data.HashSet.fromList l), rhs: unstableNub}

- hint: { lhs: nub, rhs: ordNub
        , note: "'nub' is O(n^2), 'ordNub' is O(n log n)" }

- warn: { lhs: sortBy (comparing f), rhs: sortWith f
        , note: "If the function you are using for 'comparing' is slow, use 'sortOn' instead of 'sortWith', because 'sortOn' caches applications the function and 'sortWith' doesn't." }

- warn: { lhs: sortOn fst, rhs: sortWith fst
        , note: "'sortWith' will be faster here because it doesn't do caching" }
- warn: { lhs: sortOn snd, rhs: sortWith snd
        , note: "'sortWith' will be faster here because it doesn't do caching" }
- warn: { lhs: sortOn (Down . fst), rhs: sortWith (Down . fst)
        , note: "'sortWith' will be faster here because it doesn't do caching" }
- warn: { lhs: sortOn (Down . snd), rhs: sortWith (Down . snd)
        , note: "'sortWith' will be faster here because it doesn't do caching" }

- warn: {lhs: map fst &&& map snd, rhs: unzip}

- hint: {lhs: "foldl' (flip f)", rhs: "flipfoldl' f"}

- warn: {lhs: f >>= guard, rhs: guardM}
- warn: {lhs: guard =<< f, rhs: guardM}

- hint: {lhs: fmap (fmap f) x, rhs: f <<$>> x}

- warn: {lhs: fmap concat (mapM f s), rhs: concatMapM f s}
- warn: {lhs: concat <$> mapM f s, rhs: concatMapM f s}

- warn: {lhs: fmap concat (forM f s), rhs: concatForM s f}
- warn: {lhs: fmap concat (for f s), rhs: concatForM s f}
- warn: {lhs: concat <$> forM f s, rhs: concatForM s f}
- warn: {lhs: concat <$> for f s, rhs: concatForM s f}

- hint: { lhs: fmap and (sequence s), rhs: andM s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }
- hint: { lhs: and <$> sequence s, rhs: andM s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }

- hint: { lhs: fmap or (sequence s), rhs: orM s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }
- hint: { lhs: or <$> sequence s, rhs: orM s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }

- hint: { lhs: fmap and (mapM f s), rhs: allM f s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }
- hint: { lhs: and <$> mapM f s, rhs: allM f s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }
- hint: { lhs: fmap or (mapM f s), rhs: anyM f s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }
- hint: { lhs: or <$> mapM f s, rhs: anyM f s
        , note: "Applying this hint would mean that some actions\n that were being executed previously would no longer be executed." }

- warn: {lhs: whenM (not <$> x), rhs: unlessM x}
- warn: {lhs: unlessM (not <$> x), rhs: whenM x}

- warn: {lhs: either (const True) (const False), rhs: isLeft}
- warn: {lhs: either (const False) (const True), rhs: isRight}

- warn: {lhs: either id (const a), rhs: fromLeft a}
- warn: {lhs: either (const b) id, rhs: fromRight b}

- warn: {lhs: either Just (const Nothing), rhs: leftToMaybe}
- warn: {lhs: either (const Nothing) Just, rhs: rightToMaybe}
- warn: {lhs: maybe (Left l) Right, rhs: maybeToRight}
- warn: {lhs: maybe (Right r) Left, rhs: maybeToLeft}

- warn: {lhs: fromMaybe mempty, rhs: maybeToMonoid}
- warn: {lhs: "m ?: mempty", rhs: maybeToMonoid m}


- hint: {lhs: pure (), rhs: pass}
- hint: {lhs: return (), rhs: pass}

# Probably will be reduced when function equality is done:
# https://github.com/ndmitchell/hlint/issues/434
- warn: {lhs: (case m of Just x -> f x; Nothing -> pure ()  ), rhs: whenJust m f}
- warn: {lhs: (case m of Just x -> f x; Nothing -> return ()), rhs: whenJust m f}
- warn: {lhs: (case m of Just x -> f x; Nothing -> pass     ), rhs: whenJust m f}
- warn: {lhs: (case m of Nothing -> pure ()  ; Just x -> f x), rhs: whenJust m f}
- warn: {lhs: (case m of Nothing -> return (); Just x -> f x), rhs: whenJust m f}
- warn: {lhs: (case m of Nothing -> pass     ; Just x -> f x), rhs: whenJust m f}
- warn: {lhs: (maybe (pure ())   f m), rhs: whenJust m f}
- warn: {lhs: (maybe (return ()) f m), rhs: whenJust m f}
- warn: {lhs: (maybe pass        f m), rhs: whenJust m f}

- warn: {lhs: (m >>= \case Just x -> f x; Nothing -> pure ()  ), rhs: whenJustM m f}
- warn: {lhs: (m >>= \case Just x -> f x; Nothing -> return ()), rhs: whenJustM m f}
- warn: {lhs: (m >>= \case Just x -> f x; Nothing -> pass     ), rhs: whenJustM m f}
- warn: {lhs: (m >>= \case Nothing -> pure ()  ; Just x -> f x), rhs: whenJustM m f}
- warn: {lhs: (m >>= \case Nothing -> return (); Just x -> f x), rhs: whenJustM m f}
- warn: {lhs: (m >>= \case Nothing -> pass     ; Just x -> f x), rhs: whenJustM m f}
- warn: {lhs: (maybe (pure ())   f =<< m), rhs: whenJustM m f}
- warn: {lhs: (maybe (return ()) f =<< m), rhs: whenJustM m f}
- warn: {lhs: (maybe pass        f =<< m), rhs: whenJustM m f}
- warn: {lhs: (m >>= maybe (pure ())   f), rhs: whenJustM m f}
- warn: {lhs: (m >>= maybe (return ()) f), rhs: whenJustM m f}
- warn: {lhs: (m >>= maybe pass        f), rhs: whenJustM m f}

- warn: {lhs: (case m of Just _ -> pure ()  ; Nothing -> x), rhs: whenNothing_ m x}
- warn: {lhs: (case m of Just _ -> return (); Nothing -> x), rhs: whenNothing_ m x}
- warn: {lhs: (case m of Just _ -> pass     ; Nothing -> x), rhs: whenNothing_ m x}
- warn: {lhs: (case m of Nothing -> x; Just _ -> pure ()  ), rhs: whenNothing_ m x}
- warn: {lhs: (case m of Nothing -> x; Just _ -> return ()), rhs: whenNothing_ m x}
- warn: {lhs: (case m of Nothing -> x; Just _ -> pass     ), rhs: whenNothing_ m x}
- warn: {lhs: (maybe x (\_ -> pure ()    ) m), rhs: whenNothing_ m x}
- warn: {lhs: (maybe x (\_ -> return ()  ) m), rhs: whenNothing_ m x}
- warn: {lhs: (maybe x (\_ -> pass       ) m), rhs: whenNothing_ m x}
- warn: {lhs: (maybe x (const (pure ()  )) m), rhs: whenNothing_ m x}
- warn: {lhs: (maybe x (const (return ())) m), rhs: whenNothing_ m x}
- warn: {lhs: (maybe x (const (pass     )) m), rhs: whenNothing_ m x}

- warn: {lhs: (m >>= \case Just _ -> pure ()  ; Nothing -> x), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= \case Just _ -> return (); Nothing -> x), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= \case Just _ -> pass     ; Nothing -> x), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= \case Nothing -> x; Just _ -> pure ()  ), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= \case Nothing -> x; Just _ -> return ()), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= \case Nothing -> x; Just _ -> pass     ), rhs: whenNothingM_ m x}
- warn: {lhs: (maybe x (\_ -> pure ()    ) =<< m), rhs: whenNothingM_ m x}
- warn: {lhs: (maybe x (\_ -> return ()  ) =<< m), rhs: whenNothingM_ m x}
- warn: {lhs: (maybe x (\_ -> pass       ) =<< m), rhs: whenNothingM_ m x}
- warn: {lhs: (maybe x (const (pure ()  )) =<< m), rhs: whenNothingM_ m x}
- warn: {lhs: (maybe x (const (return ())) =<< m), rhs: whenNothingM_ m x}
- warn: {lhs: (maybe x (const (pass     )) =<< m), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= maybe x (\_ -> pure ())    ), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= maybe x (\_ -> return ())  ), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= maybe x (\_ -> pass)       ), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= maybe x (const (pure ())  )), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= maybe x (const (return ()))), rhs: whenNothingM_ m x}
- warn: {lhs: (m >>= maybe x (const (pass)     )), rhs: whenNothingM_ m x}

- warn: {lhs: (case m of Left x -> f x; Right _ -> pure ()  ), rhs: whenLeft m f}
- warn: {lhs: (case m of Left x -> f x; Right _ -> return ()), rhs: whenLeft m f}
- warn: {lhs: (case m of Left x -> f x; Right _ -> pass     ), rhs: whenLeft m f}
- warn: {lhs: (case m of Right _ -> pure ()  ; Left x -> f x), rhs: whenLeft m f}
- warn: {lhs: (case m of Right _ -> return (); Left x -> f x), rhs: whenLeft m f}
- warn: {lhs: (case m of Right _ -> pass     ; Left x -> f x), rhs: whenLeft m f}
- warn: {lhs: (either f (\_ -> pure ()    ) m), rhs: whenLeft m f}
- warn: {lhs: (either f (\_ -> return ()  ) m), rhs: whenLeft m f}
- warn: {lhs: (either f (\_ -> pass       ) m), rhs: whenLeft m f}
- warn: {lhs: (either f (const (pure ()  )) m), rhs: whenLeft m f}
- warn: {lhs: (either f (const (return ())) m), rhs: whenLeft m f}
- warn: {lhs: (either f (const (pass     )) m), rhs: whenLeft m f}

- warn: {lhs: (m >>= \case Left x -> f x; Right _ -> pure ()  ), rhs: whenLeftM m f}
- warn: {lhs: (m >>= \case Left x -> f x; Right _ -> return ()), rhs: whenLeftM m f}
- warn: {lhs: (m >>= \case Left x -> f x; Right _ -> pass     ), rhs: whenLeftM m f}
- warn: {lhs: (m >>= \case Right _ -> pure ()  ; Left x -> f x), rhs: whenLeftM m f}
- warn: {lhs: (m >>= \case Right _ -> return (); Left x -> f x), rhs: whenLeftM m f}
- warn: {lhs: (m >>= \case Right _ -> pass     ; Left x -> f x), rhs: whenLeftM m f}
- warn: {lhs: (either f (\_ -> pure ()    ) =<< m), rhs: whenLeftM m f}
- warn: {lhs: (either f (\_ -> return ()  ) =<< m), rhs: whenLeftM m f}
- warn: {lhs: (either f (\_ -> pass       ) =<< m), rhs: whenLeftM m f}
- warn: {lhs: (either f (const (pure ()  )) =<< m), rhs: whenLeftM m f}
- warn: {lhs: (either f (const (return ())) =<< m), rhs: whenLeftM m f}
- warn: {lhs: (either f (const (pass     )) =<< m), rhs: whenLeftM m f}
- warn: {lhs: (m >>= either f (\_ -> pure ())    ), rhs: whenLeftM m f}
- warn: {lhs: (m >>= either f (\_ -> return ())  ), rhs: whenLeftM m f}
- warn: {lhs: (m >>= either f (\_ -> pass)       ), rhs: whenLeftM m f}
- warn: {lhs: (m >>= either f (const (pure ())  )), rhs: whenLeftM m f}
- warn: {lhs: (m >>= either f (const (return ()))), rhs: whenLeftM m f}
- warn: {lhs: (m >>= either f (const (pass)     )), rhs: whenLeftM m f}

- warn: {lhs: (case m of Right x -> f x; Left _ -> pure ()  ), rhs: whenRight m f}
- warn: {lhs: (case m of Right x -> f x; Left _ -> return ()), rhs: whenRight m f}
- warn: {lhs: (case m of Right x -> f x; Left _ -> pass     ), rhs: whenRight m f}
- warn: {lhs: (case m of Left _ -> pure ()  ; Right x -> f x), rhs: whenRight m f}
- warn: {lhs: (case m of Left _ -> return (); Right x -> f x), rhs: whenRight m f}
- warn: {lhs: (case m of Left _ -> pass     ; Right x -> f x), rhs: whenRight m f}
- warn: {lhs: (either (\_ -> pure ()    ) f m), rhs: whenRight m f}
- warn: {lhs: (either (\_ -> return ()  ) f m), rhs: whenRight m f}
- warn: {lhs: (either (\_ -> pass       ) f m), rhs: whenRight m f}
- warn: {lhs: (either (const (pure ()  )) f m), rhs: whenRight m f}
- warn: {lhs: (either (const (return ())) f m), rhs: whenRight m f}
- warn: {lhs: (either (const (pass     )) f m), rhs: whenRight m f}

- warn: {lhs: (m >>= \case Right x -> f x; Left _ -> pure ()  ), rhs: whenRightM m f}
- warn: {lhs: (m >>= \case Right x -> f x; Left _ -> return ()), rhs: whenRightM m f}
- warn: {lhs: (m >>= \case Right x -> f x; Left _ -> pass     ), rhs: whenRightM m f}
- warn: {lhs: (m >>= \case Left _ -> pure ()  ; Right x -> f x), rhs: whenRightM m f}
- warn: {lhs: (m >>= \case Left _ -> return (); Right x -> f x), rhs: whenRightM m f}
- warn: {lhs: (m >>= \case Left _ -> pass     ; Right x -> f x), rhs: whenRightM m f}
- warn: {lhs: (either (\_ -> pure ()    ) f =<< m), rhs: whenRightM m f}
- warn: {lhs: (either (\_ -> return ()  ) f =<< m), rhs: whenRightM m f}
- warn: {lhs: (either (\_ -> pass       ) f =<< m), rhs: whenRightM m f}
- warn: {lhs: (either (const (pure ()  )) f =<< m), rhs: whenRightM m f}
- warn: {lhs: (either (const (return ())) f =<< m), rhs: whenRightM m f}
- warn: {lhs: (either (const (pass     )) f =<< m), rhs: whenRightM m f}
- warn: {lhs: (m >>= either (\_ -> pure ())     f), rhs: whenRightM m f}
- warn: {lhs: (m >>= either (\_ -> return ())   f), rhs: whenRightM m f}
- warn: {lhs: (m >>= either (\_ -> pass)        f), rhs: whenRightM m f}
- warn: {lhs: (m >>= either (const (pure ())  ) f), rhs: whenRightM m f}
- warn: {lhs: (m >>= either (const (return ())) f), rhs: whenRightM m f}
- warn: {lhs: (m >>= either (const (pass)     ) f), rhs: whenRightM m f}

- warn: {lhs: "(case m of [] -> return (); (x:xs) -> f (x :| xs))", rhs: whenNotNull m f}
- warn: {lhs: "(case m of [] -> pure ()  ; (x:xs) -> f (x :| xs))", rhs: whenNotNull m f}
- warn: {lhs: "(case m of [] -> pass     ; (x:xs) -> f (x :| xs))", rhs: whenNotNull m f}
- warn: {lhs: "(case m of (x:xs) -> f (x :| xs); [] -> return ())", rhs: whenNotNull m f}
- warn: {lhs: "(case m of (x:xs) -> f (x :| xs); [] -> pure ()  )", rhs: whenNotNull m f}
- warn: {lhs: "(case m of (x:xs) -> f (x :| xs); [] -> pass     )", rhs: whenNotNull m f}
- warn: {lhs: "(m >>= \\case [] -> pass     ; (x:xs) -> f (x :| xs))", rhs: whenNotNullM m f}
- warn: {lhs: "(m >>= \\case [] -> pure ()  ; (x:xs) -> f (x :| xs))", rhs: whenNotNullM m f}
- warn: {lhs: "(m >>= \\case [] -> return (); (x:xs) -> f (x :| xs))", rhs: whenNotNullM m f}
- warn: {lhs: "(m >>= \\case (x:xs) -> f (x :| xs); [] -> pass     )", rhs: whenNotNullM m f}
- warn: {lhs: "(m >>= \\case (x:xs) -> f (x :| xs); [] -> pure ()  )", rhs: whenNotNullM m f}
- warn: {lhs: "(m >>= \\case (x:xs) -> f (x :| xs); [] -> return ())", rhs: whenNotNullM m f}

- warn: {lhs: mapMaybe leftToMaybe, rhs: lefts}
- warn: {lhs: mapMaybe rightToMaybe, rhs: rights}

############################################################################
## Reexports
############################################################################

## Applicative
- warn: { name: "Use 'Alternative' from Universum"
        , lhs: Control.Applicative.Alternative, rhs: Alternative }
- warn: { name: "Use 'empty' from Universum"
        , lhs: Control.Applicative.empty, rhs: empty }
- warn: { name: "Use '(<|>)' from Universum"
        , lhs: Control.Applicative.(<|>), rhs: (<|>) }
- warn: { name: "Use 'some' from Universum"
        , lhs: Control.Applicative.some, rhs: some }
- warn: { name: "Use 'many' from Universum"
        , lhs: Control.Applicative.many, rhs: many }
- warn: { name: "Use 'Const' from Universum"
        , lhs: Control.Applicative.Const, rhs: Const }
- warn: { name: "Use 'getConst' from Universum"
        , lhs: Control.Applicative.getConst, rhs: getConst }
- warn: { name: "Use 'ZipList' from Universum"
        , lhs: Control.Applicative.ZipList, rhs: ZipList }
- warn: { name: "Use 'getZipList' from Universum"
        , lhs: Control.Applicative.getZipList, rhs: getZipList }
- warn: { name: "Use 'liftA2' from Universum"
        , lhs: Control.Applicative.liftA2, rhs: liftA2 }
- warn: { name: "Use 'liftA3' from Universum"
        , lhs: Control.Applicative.liftA3, rhs: liftA3 }
- warn: { name: "Use 'optional' from Universum"
        , lhs: Control.Applicative.optional, rhs: optional }
- warn: { name: "Use '(<**>)' from Universum"
        , lhs: Control.Applicative.(<**>), rhs: (<**>) }

## Base
- warn: { name: "Use 'xor' from Universum"
        , lhs: Data.Bits.xor, rhs: xor }

- warn: { name: "Use 'chr' from Universum"
        , lhs: Data.Char.chr, rhs: chr }

- warn: { name: "Use 'Int16' from Universum"
        , lhs: Data.Int.Int16, rhs: Int16 }
- warn: { name: "Use 'Int32' from Universum"
        , lhs: Data.Int.Int32, rhs: Int32 }
- warn: { name: "Use 'Int64' from Universum"
        , lhs: Data.Int.Int64, rhs: Int64 }
- warn: { name: "Use 'Int8' from Universum"
        , lhs: Data.Int.Int8, rhs: Int8 }

- warn: { name: "Use 'Word16' from Universum"
        , lhs: Data.Word.Word16, rhs: Word16 }
- warn: { name: "Use 'Word32' from Universum"
        , lhs: Data.Word.Word32, rhs: Word32 }
- warn: { name: "Use 'Word64' from Universum"
        , lhs: Data.Word.Word64, rhs: Word64 }
- warn: { name: "Use 'Word8' from Universum"
        , lhs: Data.Word.Word8, rhs: Word8 }
- warn: { name: "Use 'byteSwap16' from Universum"
        , lhs: Data.Word.byteSwap16, rhs: byteSwap16 }
- warn: { name: "Use 'byteSwap32' from Universum"
        , lhs: Data.Word.byteSwap32, rhs: byteSwap32 }
- warn: { name: "Use 'byteSwap64' from Universum"
        , lhs: Data.Word.byteSwap64, rhs: byteSwap64 }

- warn: { name: "Use 'Natural' from Universum"
        , lhs: Numeric.Natural.Natural, rhs: Natural }

- warn: { name: "Use 'Handle' from Universum"
        , lhs: System.IO.Handle, rhs: Handle }
- warn: { name: "Use 'IOMode' from Universum"
        , lhs: System.IO.IOMode, rhs: IOMode }
- warn: { name: "Use 'ReadMode' from Universum"
        , lhs: System.IO.ReadMode, rhs: ReadMode }
- warn: { name: "Use 'WriteMode' from Universum"
        , lhs: System.IO.WriteMode, rhs: WriteMode }
- warn: { name: "Use 'AppendMode' from Universum"
        , lhs: System.IO.AppendMode, rhs: AppendMode }
- warn: { name: "Use 'ReadWriteMode' from Universum"
        , lhs: System.IO.ReadWriteMode, rhs: ReadWriteMode }
- warn: { name: "Use 'stderr' from Universum"
        , lhs: System.IO.stderr, rhs: stderr }
- warn: { name: "Use 'stdin' from Universum"
        , lhs: System.IO.stdin, rhs: stdin }
- warn: { name: "Use 'stdout' from Universum"
        , lhs: System.IO.stdout, rhs: stdout }
- warn: { name: "Use 'withFile' from Universum"
        , lhs: System.IO.withFile, rhs: withFile }

- warn: { name: "Use 'foldlM' from Universum"
        , lhs: Data.Foldable.foldlM, rhs: foldlM }
- warn: { name: "Use 'foldrM' from Universum"
        , lhs: Data.Foldable.foldrM, rhs: foldrM }
- warn: { name: "Use 'maximumBy' from Universum"
        , lhs: Data.Foldable.maximumBy, rhs: maximumBy }
- warn: { name: "Use 'minimumBy' from Universum"
        , lhs: Data.Foldable.minimumBy, rhs: minimumBy }

- warn: { name: "Use 'Down' from Universum"
        , lhs: Data.Ord.Down, rhs: Down }
- warn: { name: "Use 'comparing' from Universum"
        , lhs: Data.Ord.comparing, rhs: comparing }

- warn: { name: "Use 'fmapDefault' from Universum"
        , lhs: Data.Traversable.fmapDefault, rhs: fmapDefault }
- warn: { name: "Use 'foldMapDefault' from Universum"
        , lhs: Data.Traversable.foldMapDefault, rhs: foldMapDefault }
- warn: { name: "Use 'forM' from Universum"
        , lhs: Data.Traversable.forM, rhs: forM }
- warn: { name: "Use 'mapAccumL' from Universum"
        , lhs: Data.Traversable.mapAccumL, rhs: mapAccumL }
- warn: { name: "Use 'mapAccumR' from Universum"
        , lhs: Data.Traversable.mapAccumR, rhs: mapAccumR }

- warn: { name: "Use 'Proxy' from Universum"
        , lhs: Data.Proxy.Proxy, rhs: Proxy }

- warn: { name: "Use 'Typeable' from Universum"
        , lhs: Data.Typeable.Typeable, rhs: Typeable }

- warn: { name: "Use 'Void' from Universum"
        , lhs: Data.Void.Void, rhs: Void }
- warn: { name: "Use 'absurd' from Universum"
        , lhs: Data.Void.absurd, rhs: absurd }
- warn: { name: "Use 'vacuous' from Universum"
        , lhs: Data.Void.vacuous, rhs: vacuous }

- warn: { name: "Use 'maxInt' from Universum"
        , lhs: Data.Base.maxInt, rhs: maxInt }
- warn: { name: "Use 'minInt' from Universum"
        , lhs: Data.Base.minInt, rhs: minInt }
- warn: { name: "Use 'ord' from Universum"
        , lhs: Data.Base.ord, rhs: ord }

- warn: { name: "Use 'boundedEnumFrom' from Universum"
        , lhs: GHC.Enum.boundedEnumFrom, rhs: boundedEnumFrom }
- warn: { name: "Use 'boundedEnumFromThen' from Universum"
        , lhs: GHC.Enum.boundedEnumFromThen, rhs: boundedEnumFromThen }

- warn: { name: "Use 'Constraint' from Universum"
        , lhs: GHC.Exts.Constraint, rhs: Constraint }
- warn: { name: "Use 'FunPtr' from Universum"
        , lhs: GHC.Exts.FunPtr, rhs: FunPtr }
- warn: { name: "Use 'Ptr' from Universum"
        , lhs: GHC.Exts.Ptr, rhs: Ptr }

- warn: { name: "Use 'Generic' from Universum"
        , lhs: GHC.Generics.Generic, rhs: Generic }

- warn: { name: "Use 'Ratio' from Universum"
        , lhs: GHC.Real.Ratio, rhs: Ratio }
- warn: { name: "Use 'Rational' from Universum"
        , lhs: GHC.Real.Rational, rhs: Rational }

- warn: { name: "Use 'CmpNat' from Universum"
        , lhs: GHC.TypeNats.CmpNat, rhs: CmpNat }
- warn: { name: "Use 'KnownNat' from Universum"
        , lhs: GHC.TypeNats.KnownNat, rhs: KnownNat }
- warn: { name: "Use 'Nat' from Universum"
        , lhs: GHC.TypeNats.Nat, rhs: Nat }
- warn: { name: "Use 'SomeNat' from Universum"
        , lhs: GHC.TypeNats.SomeNat, rhs: SomeNat }
- warn: { name: "Use 'natVal' from Universum"
        , lhs: GHC.TypeNats.natVal, rhs: natVal }
- warn: { name: "Use 'someNatVal' from Universum"
        , lhs: GHC.TypeNats.someNatVal, rhs: someNatVal }

- warn: { name: "Use 'CmpNat' from Universum"
        , lhs: GHC.TypeLits.CmpNat, rhs: CmpNat }
- warn: { name: "Use 'KnownNat' from Universum"
        , lhs: GHC.TypeLits.KnownNat, rhs: KnownNat }
- warn: { name: "Use 'Nat' from Universum"
        , lhs: GHC.TypeLits.Nat, rhs: Nat }
- warn: { name: "Use 'SomeNat' from Universum"
        , lhs: GHC.TypeLits.SomeNat, rhs: SomeNat }
- warn: { name: "Use 'natVal' from Universum"
        , lhs: GHC.TypeLits.natVal, rhs: natVal }
- warn: { name: "Use 'someNatVal' from Universum"
        , lhs: GHC.TypeLits.someNatVal, rhs: someNatVal }

- warn: { name: "Use 'Coercible' from Universum"
        , lhs: GHC.Types.Coercible, rhs: Coercible }

- warn: { name: "Use 'getStackTrace' from Universum"
        , lhs: GHC.ExecutionStack.getStackTrace, rhs: getStackTrace }
- warn: { name: "Use 'showStackTrace' from Universum"
        , lhs: GHC.ExecutionStack.showStackTrace, rhs: showStackTrace }

- warn: { name: "Use 'IsLabel' from Universum"
        , lhs: GHC.OverloadedLabels.IsLabel, rhs: IsLabel }
- warn: { name: "Use 'fromLabel' from Universum"
        , lhs: GHC.OverloadedLabels.fromLabel, rhs: fromLabel }

- warn: { name: "Use 'CallStack' from Universum"
        , lhs: GHC.Stack.CallStack, rhs: CallStack }
- warn: { name: "Use 'HasCallStack' from Universum"
        , lhs: GHC.Stack.HasCallStack, rhs: HasCallStack }
- warn: { name: "Use 'callStack' from Universum"
        , lhs: GHC.Stack.callStack, rhs: callStack }
- warn: { name: "Use 'currentCallStack' from Universum"
        , lhs: GHC.Stack.currentCallStack, rhs: currentCallStack }
- warn: { name: "Use 'getCallStack' from Universum"
        , lhs: GHC.Stack.getCallStack, rhs: getCallStack }
- warn: { name: "Use 'prettyCallStack' from Universum"
        , lhs: GHC.Stack.prettyCallStack, rhs: prettyCallStack }
- warn: { name: "Use 'prettySrcLoc' from Universum"
        , lhs: GHC.Stack.prettySrcLoc, rhs: prettySrcLoc }
- warn: { name: "Use 'withFrozenCallStack' from Universum"
        , lhs: GHC.Stack.withFrozenCallStack, rhs: withFrozenCallStack }

- warn: { name: "Use 'Type' from Universum"
        , lhs: Data.Kind.Type, rhs: Type }

## Bool

- warn: { name: "Use 'guard' from Universum"
        , lhs: Control.Monad.guard, rhs: guard }
- warn: { name: "Use 'unless' from Universum"
        , lhs: Control.Monad.unless, rhs: unless }
- warn: { name: "Use 'when' from Universum"
        , lhs: Control.Monad.when, rhs: when }
- warn: { name: "Use 'bool' from Universum"
        , lhs: Data.Bool.bool, rhs: bool }

## Container
- warn: { name: "Use 'Hashable' from Universum"
        , lhs: Data.Hashable.Hashable, rhs: Hashable }
- warn: { name: "Use 'hashWithSalt' from Universum"
        , lhs: Data.Hashable.hashWithSalt, rhs: hashWithSalt }
- warn: { name: "Use 'HashMap' from Universum"
        , lhs: Data.HashMap.Strict.HashMap, rhs: HashMap }
- warn: { name: "Use 'HashSet' from Universum"
        , lhs: Data.HashSet.HashSet, rhs: HashSet }
- warn: { name: "Use 'IntMap' from Universum"
        , lhs: Data.IntMap.Strict.IntMap, rhs: IntMap }
- warn: { name: "Use 'IntSet' from Universum"
        , lhs: Data.IntSet.IntSet, rhs: IntSet }
- warn: { name: "Use 'Map' from Universum"
        , lhs: Data.Map.Strict.Map, rhs: Map }
- warn: { name: "Use 'Sequence' from Universum"
        , lhs: Data.Sequence.Sequence, rhs: Sequence }
- warn: { name: "Use 'Set' from Universum"
        , lhs: Data.Set.Set, rhs: Set }
- warn: { name: "Use 'swap' from Universum"
        , lhs: Data.Tuple.swap, rhs: swap }
- warn: { name: "Use 'Vector' from Universum"
        , lhs: Data.Vector.Vector, rhs: Vector }

## Deepseq
- warn: { name: "Use 'NFData' from Universum"
        , lhs: Control.DeepSeq.NFData, rhs: NFData }
- warn: { name: "Use 'rnf' from Universum"
        , lhs: Control.DeepSeq.rnf, rhs: rnf }
- warn: { name: "Use 'deepseq' from Universum"
        , lhs: Control.DeepSeq.deepseq, rhs: deepseq }
- warn: { name: "Use 'force' from Universum"
        , lhs: Control.DeepSeq.force, rhs: force }
- warn: { name: "Use '($!!)' from Universum"
        , lhs: "Control.DeepSeq.($!!)", rhs: "($!!)" }

## Exception
- warn: { name: "Use 'Exception' from Universum"
        , lhs: Control.Exception.Exception, rhs: Exception }
- warn: { name: "Use 'toException' from Universum"
        , lhs: Control.Exception.toException, rhs: toException }
- warn: { name: "Use 'fromException' from Universum"
        , lhs: Control.Exception.fromException, rhs: fromException }

- warn: { name: "Use 'Exception' from Universum"
        , lhs: Control.Exception.Safe.Exception, rhs: Exception }
- warn: { name: "Use 'toException' from Universum"
        , lhs: Control.Exception.Safe.toException, rhs: toException }
- warn: { name: "Use 'fromException' from Universum"
        , lhs: Control.Exception.Safe.fromException, rhs: fromException }
- warn: { name: "Use 'displayException' from Universum"
        , lhs: Control.Exception.Safe.displayException, rhs: displayException }
- warn: { name: "Use 'MonadCatch' from Universum"
        , lhs: Control.Exception.Safe.MonadCatch, rhs: MonadCatch }
- warn: { name: "Use 'MonadMask' from Universum"
        , lhs: Control.Exception.Safe.MonadMask, rhs: MonadMask }
- warn: { name: "Use 'mask' from Universum"
        , lhs: Control.Exception.Safe.mask, rhs: mask }
- warn: { name: "Use 'uninterruptibleMask' from Universum"
        , lhs: Control.Exception.Safe.uninterruptibleMask, rhs: uninterruptibleMask }
- warn: { name: "Use 'MonadThrow' from Universum"
        , lhs: Control.Exception.Safe.MonadThrow, rhs: MonadThrow }
- warn: { name: "Use 'SomeException' from Universum"
        , lhs: Control.Exception.Safe.SomeException, rhs: SomeException }
- warn: { name: "Use 'bracket' from Universum"
        , lhs: Control.Exception.Safe.bracket, rhs: bracket }
- warn: { name: "Use 'bracketOnError' from Universum"
        , lhs: Control.Exception.Safe.bracketOnError, rhs: bracketOnError }
- warn: { name: "Use 'bracket_' from Universum"
        , lhs: Control.Exception.Safe.bracket_, rhs: bracket_ }
- warn: { name: "Use 'catch' from Universum"
        , lhs: Control.Exception.Safe.catch, rhs: catch }
- warn: { name: "Use 'catchAny' from Universum"
        , lhs: Control.Exception.Safe.catchAny, rhs: catchAny }
- warn: { name: "Use 'finally' from Universum"
        , lhs: Control.Exception.Safe.finally, rhs: finally }
- warn: { name: "Use 'handleAny' from Universum"
        , lhs: Control.Exception.Safe.handleAny, rhs: handleAny }
- warn: { name: "Use 'onException' from Universum"
        , lhs: Control.Exception.Safe.onException, rhs: onException }
- warn: { name: "Use 'throwM' from Universum"
        , lhs: Control.Exception.Safe.throwM, rhs: throwM }
- warn: { name: "Use 'try' from Universum"
        , lhs: Control.Exception.Safe.try, rhs: try }
- warn: { name: "Use 'tryAny' from Universum"
        , lhs: Control.Exception.Safe.tryAny, rhs: tryAny }

## Function
- warn: { name: "Use 'fix' from Universum"
        , lhs: Data.Function.fix, rhs: fix }
- warn: { name: "Use 'on' from Universum"
        , lhs: Data.Function.on, rhs: Universum.on } # FIXME

## Functor
- warn: { name: "Use '(&&&)' from Universum"
        , lhs: Control.Arrow.(&&&), rhs: (&&&) }
- warn: { name: "Use 'Bifunctor' from Universum"
        , lhs: Data.Bifunctor.Bifunctor, rhs: Bifunctor }
- warn: { name: "Use 'bimap' from Universum"
        , lhs: Data.Bifunctor.bimap, rhs: bimap }
- warn: { name: "Use 'first' from Universum"
        , lhs: Data.Bifunctor.first, rhs: first }
- warn: { name: "Use 'second' from Universum"
        , lhs: Data.Bifunctor.second, rhs: second }
- warn: { name: "Use 'void' from Universum"
        , lhs: Data.Functor.void, rhs: void }
- warn: { name: "Use '($>)' from Universum"
        , lhs: Data.Functor.($>), rhs: ($>) }
- warn: { name: "Use 'Compose' from Universum"
        , lhs: Data.Functor.Compose.Compose, rhs: Compose }
- warn: { name: "Use 'getCompose' from Universum"
        , lhs: Data.Functor.Compose.getCompose, rhs: getCompose }
- warn: { name: "Use 'Identity' from Universum"
        , lhs: Data.Functor.Identity.Identity, rhs: Identity }
- warn: { name: "Use 'runIdentity' from Universum"
        , lhs: Data.Functor.Identity.runIdentity, rhs: runIdentity }

## List
- warn: { name: "Use 'genericDrop' from Universum"
        , lhs: Data.List.genericDrop, rhs: genericDrop }
- warn: { name: "Use 'genericLength' from Universum"
        , lhs: Data.List.genericLength, rhs: genericLength }
- warn: { name: "Use 'genericReplicate' from Universum"
        , lhs: Data.List.genericReplicate, rhs: genericReplicate }
- warn: { name: "Use 'genericSplitAt' from Universum"
        , lhs: Data.List.genericSplitAt, rhs: genericSplitAt }
- warn: { name: "Use 'genericTake' from Universum"
        , lhs: Data.List.genericTake, rhs: genericTake }
- warn: { name: "Use 'group' from Universum"
        , lhs: Data.List.group, rhs: group }
- warn: { name: "Use 'inits' from Universum"
        , lhs: Data.List.inits, rhs: inits }
- warn: { name: "Use 'intercalate' from Universum"
        , lhs: Data.List.intercalate, rhs: intercalate }
- warn: { name: "Use 'intersperse' from Universum"
        , lhs: Data.List.intersperse, rhs: intersperse }
- warn: { name: "Use 'isPrefixOf' from Universum"
        , lhs: Data.List.isPrefixOf, rhs: isPrefixOf }
- warn: { name: "Use 'permutations' from Universum"
        , lhs: Data.List.permutations, rhs: permutations }
- warn: { name: "Use 'sort' from Universum"
        , lhs: Data.List.sort, rhs: sort }
- warn: { name: "Use 'sortBy' from Universum"
        , lhs: Data.List.sortBy, rhs: sortBy }
- warn: { name: "Use 'sortOn' from Universum"
        , lhs: Data.List.sortOn, rhs: sortOn }
- warn: { name: "Use 'subsequences' from Universum"
        , lhs: Data.List.subsequences, rhs: subsequences }
- warn: { name: "Use 'tails' from Universum"
        , lhs: Data.List.tails, rhs: tails }
- warn: { name: "Use 'transpose' from Universum"
        , lhs: Data.List.transpose, rhs: transpose }
- warn: { name: "Use 'unfoldr' from Universum"
        , lhs: Data.List.unfoldr, rhs: unfoldr }

- warn: { name: "Use 'NonEmpty' from Universum"
        , lhs: Data.List.NonEmpty.NonEmpty, rhs: NonEmpty }
- warn: { name: "Use '(:|)' from Universum"
        , lhs: "Data.List.NonEmpty.(:|)", rhs: "(:|)"}
- warn: { name: "Use 'nonEmpty' from Universum"
        , lhs: Data.List.NonEmpty.nonEmpty, rhs: nonEmpty}
- warn: { name: "Use 'head' from Universum"
        , lhs: Data.List.NonEmpty.head, rhs: head }
- warn: { name: "Use 'init' from Universum"
        , lhs: Data.List.NonEmpty.init, rhs: init }
- warn: { name: "Use 'last' from Universum"
        , lhs: Data.List.NonEmpty.last, rhs: last }
- warn: { name: "Use 'tail' from Universum"
        , lhs: Data.List.NonEmpty.tail, rhs: tail }
- warn: { name: "Use 'sortWith' from Universum"
        , lhs: GHC.Exts.sortWith, rhs: sortWith }

## Monad
- warn: { name: "Use '(>=>)' from Universum"
        , lhs: Control.Monad.(>=>), rhs: (>=>) }
- warn: { name: "Use '(<=<)' from Universum"
        , lhs: Control.Monad.(<=<), rhs: (<=<) }
- warn: { name: "Use 'forever' from Universum"
        , lhs: Control.Monad.forever, rhs: forever }
- warn: { name: "Use 'join' from Universum"
        , lhs: Control.Monad.join, rhs: join }
- warn: { name: "Use 'mfilter' from Universum"
        , lhs: Control.Monad.mfilter, rhs: mfilter }
- warn: { name: "Use 'filterM' from Universum"
        , lhs: Control.Monad.filterM, rhs: filterM }
- warn: { name: "Use 'mapAndUnzipM' from Universum"
        , lhs: Control.Monad.mapAndUnzipM, rhs: mapAndUnzipM }
- warn: { name: "Use 'zipWithM' from Universum"
        , lhs: Control.Monad.zipWithM, rhs: zipWithM }
- warn: { name: "Use 'zipWithM_' from Universum"
        , lhs: Control.Monad.zipWithM_, rhs: zipWithM_ }
- warn: { name: "Use 'foldM' from Universum"
        , lhs: Control.Monad.foldM, rhs: foldM }
- warn: { name: "Use 'foldM_' from Universum"
        , lhs: Control.Monad.foldM_, rhs: foldM_ }
- warn: { name: "Use 'replicateM' from Universum"
        , lhs: Control.Monad.replicateM, rhs: replicateM }
- warn: { name: "Use 'replicateM_' from Universum"
        , lhs: Control.Monad.replicateM_, rhs: replicateM_ }
- warn: { name: "Use 'liftM2' from Universum"
        , lhs: Control.Monad.liftM2, rhs: liftM2 }
- warn: { name: "Use 'liftM3' from Universum"
        , lhs: Control.Monad.liftM3, rhs: liftM3 }
- warn: { name: "Use 'liftM4' from Universum"
        , lhs: Control.Monad.liftM4, rhs: liftM4 }
- warn: { name: "Use 'liftM5' from Universum"
        , lhs: Control.Monad.liftM5, rhs: liftM5 }
- warn: { name: "Use 'ap' from Universum"
        , lhs: Control.Monad.ap, rhs: ap }
- warn: { name: "Use '(<$!>)' from Universum"
        , lhs: Control.Monad.(<$!>), rhs: (<$!>) }

- warn: { name: "Use 'ExceptT' from Universum"
        , lhs: Control.Monad.Except.ExceptT, rhs: ExceptT }
- warn: { name: "Use 'runExceptT' from Universum"
        , lhs: Control.Monad.Except.runExceptT, rhs: runExceptT }

- warn: { name: "Use 'MonadReader' from Universum"
        , lhs: Control.Monad.Reader.MonadReader, rhs: MonadReader }
- warn: { name: "Use 'Reader' from Universum"
        , lhs: Control.Monad.Reader.Reader, rhs: Reader }
- warn: { name: "Use 'ReaderT' from Universum"
        , lhs: Control.Monad.Reader.ReaderT, rhs: ReaderT }
- warn: { name: "Use 'runReaderT' from Universum"
        , lhs: Control.Monad.Reader.runReaderT, rhs: runReaderT }
- warn: { name: "Use 'ask' from Universum"
        , lhs: Control.Monad.Reader.ask, rhs: ask }
- warn: { name: "Use 'local' from Universum"
        , lhs: Control.Monad.Reader.local, rhs: local }
- warn: { name: "Use 'reader' from Universum"
        , lhs: Control.Monad.Reader.reader, rhs: reader }
- warn: { name: "Use 'runReader' from Universum"
        , lhs: Control.Monad.Reader.runReader, rhs: runReader }

- warn: { name: "Use 'MonadState' from Universum"
        , lhs: Control.Monad.State.Strict.MonadState, rhs: MonadState }
- warn: { name: "Use 'State' from Universum"
        , lhs: Control.Monad.State.Strict.State, rhs: State }
- warn: { name: "Use 'StateT' from Universum"
        , lhs: Control.Monad.State.Strict.StateT, rhs: StateT }
- warn: { name: "Use 'runStateT' from Universum"
        , lhs: Control.Monad.State.Strict.runStateT, rhs: runStateT }
- warn: { name: "Use 'evalState' from Universum"
        , lhs: Control.Monad.State.Strict.evalState, rhs: evalState }
- warn: { name: "Use 'evalStateT' from Universum"
        , lhs: Control.Monad.State.Strict.evalStateT, rhs: evalStateT }
- warn: { name: "Use 'execState' from Universum"
        , lhs: Control.Monad.State.Strict.execState, rhs: execState }
- warn: { name: "Use 'execStateT' from Universum"
        , lhs: Control.Monad.State.Strict.execStateT, rhs: execStateT }
- warn: { name: "Use 'get' from Universum"
        , lhs: Control.Monad.State.Strict.get, rhs: get }
- warn: { name: "Use 'gets' from Universum"
        , lhs: Control.Monad.State.Strict.gets, rhs: gets }
- warn: { name: "Use 'modify' from Universum"
        , lhs: Control.Monad.State.Strict.modify, rhs: modify }
- warn: { name: "Use 'modify'' from Universum"
        , lhs: "Control.Monad.State.Strict.modify'", rhs: "modify'" }
- warn: { name: "Use 'put' from Universum"
        , lhs: Control.Monad.State.Strict.put, rhs: put }
- warn: { name: "Use 'runState' from Universum"
        , lhs: Control.Monad.State.Strict.runState, rhs: runState }
- warn: { name: "Use 'state' from Universum"
        , lhs: Control.Monad.State.Strict.state, rhs: state }
- warn: { name: "Use 'withState' from Universum"
        , lhs: Control.Monad.State.Strict.withState, rhs: withState }

- warn: { name: "Use 'MonadFail' from Universum"
        , lhs: Control.Monad.Fail.MonadFail, rhs: MonadFail }


- warn: { name: "Use 'MonadIO' from Universum"
        , lhs: Control.Monad.Trans.MonadIO, rhs: MonadIO }
- warn: { name: "Use 'MonadTrans' from Universum"
        , lhs: Control.Monad.Trans.MonadTrans, rhs: MonadTrans }
- warn: { name: "Use 'lift' from Universum"
        , lhs: Control.Monad.Trans.lift, rhs: lift }
- warn: { name: "Use 'liftIO' from Universum"
        , lhs: Control.Monad.Trans.liftIO, rhs: liftIO }

- warn: { name: "Use 'IdentityT' from Universum"
        , lhs: Control.Monad.Trans.Identity.IdentityT, rhs: IdentityT }
- warn: { name: "Use 'runIdentityT' from Universum"
        , lhs: Control.Monad.Trans.Identity.runIdentityT, rhs: runIdentityT }

- warn: { name: "Use 'MaybeT' from Universum"
        , lhs: Control.Monad.Trans.Maybe.MaybeT, rhs: MaybeT }
- warn: { name: "Use 'maybeToExceptT' from Universum"
        , lhs: Control.Monad.Trans.Maybe.maybeToExceptT, rhs: maybeToExceptT }
- warn: { name: "Use 'exceptToMaybeT' from Universum"
        , lhs: Control.Monad.Trans.Maybe.exceptToMaybeT, rhs: exceptToMaybeT }

- warn: { name: "Use 'catMaybes' from Universum"
        , lhs: Data.Maybe.catMaybes, rhs: catMaybes }
- warn: { name: "Use 'fromMaybe' from Universum"
        , lhs: Data.Maybe.fromMaybe, rhs: fromMaybe }
- warn: { name: "Use 'isJust' from Universum"
        , lhs: Data.Maybe.isJust, rhs: isJust }
- warn: { name: "Use 'isNothing' from Universum"
        , lhs: Data.Maybe.isNothing, rhs: isNothing }
- warn: { name: "Use 'listToMaybe' from Universum"
        , lhs: Data.Maybe.listToMaybe, rhs: listToMaybe }
- warn: { name: "Use 'mapMaybe' from Universum"
        , lhs: Data.Maybe.mapMaybe, rhs: mapMaybe }
- warn: { name: "Use 'maybeToList' from Universum"
        , lhs: Data.Maybe.maybeToList, rhs: maybeToList }

- warn: { name: "Use 'isLeft' from Universum"
        , lhs: Data.Either.isLeft, rhs: isLeft }
- warn: { name: "Use 'isRight' from Universum"
        , lhs: Data.Either.isRight, rhs: isRight }
- warn: { name: "Use 'lefts' from Universum"
        , lhs: Data.Either.lefts, rhs: lefts }
- warn: { name: "Use 'partitionEithers' from Universum"
        , lhs: Data.Either.partitionEithers, rhs: partitionEithers }
- warn: { name: "Use 'rights' from Universum"
        , lhs: Data.Either.rights, rhs: rights }

- warn: { name: "Use 'newTVar' from Universum"
        , lhs: Control.Concurrent.STM.TVar.newTVar, rhs: newTVar }
- warn: { name: "Use 'readTVar' from Universum"
        , lhs: Control.Concurrent.STM.TVar.readTVar, rhs: readTVar }
- warn: { name: "Use 'writeTVar' from Universum"
        , lhs: Control.Concurrent.STM.TVar.writeTVar, rhs: writeTVar }
- warn: { name: "Use 'modifyTVar'' from Universum"
        , lhs: "Control.Concurrent.STM.TVar.modifyTVar'", rhs: "modifyTVar'" }
- warn: { name: "Use 'newTVarIO' from Universum"
        , lhs: Control.Concurrent.STM.TVar.newTVarIO, rhs: newTVarIO }
- warn: { name: "Use 'readTVarIO' from Universum"
        , lhs: Control.Concurrent.STM.TVar.readTVarIO, rhs: readTVarIO }

- warn: { name: "Use 'newIORef' from Universum"
        , lhs: Data.IORef.newIORef, rhs: newIORef }
- warn: { name: "Use 'readIORef' from Universum"
        , lhs: Data.IORef.readIORef, rhs: readIORef }
- warn: { name: "Use 'writeIORef' from Universum"
        , lhs: Data.IORef.writeIORef, rhs: writeIORef }
- warn: { name: "Use 'modifyIORef' from Universum"
        , lhs: Data.IORef.modifyIORef, rhs: modifyIORef }
- warn: { name: "Use 'modifyIORef'' from Universum"
        , lhs: "Data.IORef.modifyIORef'", rhs: "modifyIORef'" }
- warn: { name: "Use 'atomicModifyIORef' from Universum"
        , lhs: Data.IORef.atomicModifyIORef, rhs: atomicModifyIORef }
- warn: { name: "Use 'atomicModifyIORef'' from Universum"
        , lhs: "Data.IORef.atomicModifyIORef'", rhs: "atomicModifyIORef'" }
- warn: { name: "Use 'atomicWriteIORef' from Universum"
        , lhs: Data.IORef.atomicWriteIORef, rhs: atomicWriteIORef }

## Monoid
- warn: { name: "Use 'All' from Universum"
        , lhs: Data.Monoid.All, rhs: All }
- warn: { name: "Use 'Alt' from Universum"
        , lhs: Data.Monoid.Alt, rhs: Alt }
- warn: { name: "Use 'Any' from Universum"
        , lhs: Data.Monoid.Any, rhs: Any }
- warn: { name: "Use 'Dual' from Universum"
        , lhs: Data.Monoid.Dual, rhs: Dual }
- warn: { name: "Use 'Endo' from Universum"
        , lhs: Data.Monoid.Endo, rhs: Endo }
- warn: { name: "Use 'First' from Universum"
        , lhs: Data.Monoid.First, rhs: First }
- warn: { name: "Use 'Last' from Universum"
        , lhs: Data.Monoid.Last, rhs: Last }
- warn: { name: "Use 'Product' from Universum"
        , lhs: Data.Monoid.Product, rhs: Product }
- warn: { name: "Use 'Sum' from Universum"
        , lhs: Data.Monoid.Sum, rhs: Sum }

- warn: { name: "Use 'Option' from Universum"
        , lhs: Data.Semigroup.Option, rhs: Option }
- warn: { name: "Use 'Semigroup' from Universum"
        , lhs: Data.Semigroup.Semigroup, rhs: Semigroup }
- warn: { name: "Use 'sconcat' from Universum"
        , lhs: Data.Semigroup.sconcat, rhs: sconcat }
- warn: { name: "Use 'stimes' from Universum"
        , lhs: Data.Semigroup.stimes, rhs: stimes }
- warn: { name: "Use '(<>)' from Universum"
        , lhs: Data.Semigroup.(<>), rhs: (<>) }
- warn: { name: "Use 'WrappedMonoid' from Universum"
        , lhs: Data.Semigroup.WrappedMonoid, rhs: WrappedMonoid }
- warn: { name: "Use 'cycle1' from Universum"
        , lhs: Data.Semigroup.cycle1, rhs: cycle1 }
- warn: { name: "Use 'mtimesDefault' from Universum"
        , lhs: Data.Semigroup.mtimesDefault, rhs: mtimesDefault }
- warn: { name: "Use 'stimesIdempotent' from Universum"
        , lhs: Data.Semigroup.stimesIdempotent, rhs: stimesIdempotent }
- warn: { name: "Use 'stimesIdempotentMonoid' from Universum"
        , lhs: Data.Semigroup.stimesIdempotentMonoid, rhs: stimesIdempotentMonoid }
- warn: { name: "Use 'stimesMonoid' from Universum"
        , lhs: Data.Semigroup.stimesMonoid, rhs: stimesMonoid }

## String
- warn: { name: "Use 'ByteString' from Universum"
        , lhs: Data.ByteString.ByteString, rhs: ByteString }
- warn: { name: "Use 'IsString' from Universum"
        , lhs: Data.String.IsString, rhs: IsString }

- warn: { name: "Use 'Text' from Universum"
        , lhs: Data.Text.Text, rhs: Text }
- warn: { name: "Use 'lines' from Universum"
        , lhs: Data.Text.lines, rhs: lines }
- warn: { name: "Use 'unlines' from Universum"
        , lhs: Data.Text.unlines, rhs: unlines }
- warn: { name: "Use 'words' from Universum"
        , lhs: Data.Text.words, rhs: words }
- warn: { name: "Use 'unwords' from Universum"
        , lhs: Data.Text.unwords, rhs: unwords }

- warn: { name: "Use 'LText' from Universum"
        , lhs: Data.Text.Lazy.Text, rhs: LText }
- warn: { name: "Use 'LByteString' from Universum"
        , lhs: Data.ByteString.Lazy.LByteString, rhs: LByteString }

- warn: { name: "Use 'Buildable' from Universum"
        , lhs: Data.Text.Buildable, rhs: Buildable }
- warn: { name: "Use 'decodeUtf8'' from Universum"
        , lhs: "Data.Text.Encoding.decodeUtf8'", rhs: "decodeUtf8'" }
- warn: { name: "Use 'decodeUtf8With' from Universum"
        , lhs: Data.Text.Encoding.decodeUtf8With, rhs: decodeUtf8With }

- warn: { name: "Use 'OnDecodeError' from Universum"
        , lhs: Data.Text.Encoding.Error.OnDecodeError, rhs: OnDecodeError }
- warn: { name: "Use 'OnDecodeError' from Universum"
        , lhs: Data.Text.Encoding.Error.OnDecodeError, rhs: OnDecodeError }
- warn: { name: "Use 'OnError' from Universum"
        , lhs: Data.Text.Encoding.Error.OnError, rhs: OnError }
- warn: { name: "Use 'UnicodeException' from Universum"
        , lhs: Data.Text.Encoding.Error.UnicodeException, rhs: UnicodeException }
- warn: { name: "Use 'lenientDecode' from Universum"
        , lhs: Data.Text.Encoding.Error.lenientDecode, rhs: lenientDecode }
- warn: { name: "Use 'strictDecode' from Universum"
        , lhs: Data.Text.Encoding.Error.strictDecode, rhs: strictDecode }

- warn: { name: "Use 'fromStrict' from Universum"
        , lhs: Data.Text.Lazy.fromStrict, rhs: fromStrict }
- warn: { name: "Use 'toStrict' from Universum"
        , lhs: Data.Text.Lazy.toStrict, rhs: toStrict }

- warn: { name: "Use 'readMaybe' from Universum"
        , lhs: Text.Read.readMaybe, rhs: readMaybe }

- warn: { name: "Use 'getLine' from Universum"
        , lhs: Data.Text.IO.getLine, rhs: getLine }
- warn: { name: "Use 'readFile' from Universum"
        , lhs: Data.Text.IO.readFile, rhs: readFile }
- warn: { name: "Use 'writeFile' from Universum"
        , lhs: Data.Text.IO.writeFile, rhs: writeFile }
- warn: { name: "Use 'appendFile' from Universum"
        , lhs: Data.Text.IO.appendFile, rhs: appendFile }

## Unsafe
- warn: { name: "Use 'head' from Unsafe"
        , lhs: Data.List.head, rhs: Unsafe.head
        , note: "Use 'import qualified Unsafe as Unsafe (head)'" }
- warn: { name: "Use 'tail' from Unsafe"
        , lhs: Data.List.tail, rhs: Unsafe.tail
        , note: "Use 'import qualified Unsafe as Unsafe (tail)'" }
- warn: { name: "Use 'init' from Unsafe"
        , lhs: Data.List.init, rhs: Unsafe.init
        , note: "Use 'import qualified Unsafe as Unsafe (init)'" }
- warn: { name: "Use 'last' from Unsafe"
        , lhs: Data.List.last, rhs: Unsafe.last
        , note: "Use 'import qualified Unsafe as Unsafe (last)'" }
- warn: { name: "Use '(!!)' from Unsafe"
        , lhs: "Data.List.(!!)", rhs: "Unsafe.(!!)"
        , note: "Use 'import qualified Unsafe as Unsafe ((!!))'" }
- warn: { name: "Use 'fromJust' from Unsafe"
        , lhs: "Data.Maybe.fromJust", rhs: "Unsafe.fromJust"
        , note: "Use 'import qualified Unsafe as Unsafe (fromJust)'" }

############################################################################
## Lifted functions in Universum
############################################################################

## concurrency

- warn: { name: "liftIO is not needed", lhs: liftIO newEmptyMVar, rhs: newEmptyMVar
        , note: "If you import 'newEmptyMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (newMVar x), rhs: newMVar x
        , note: "If you import 'newMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (putMVar x y), rhs: putMVar x y
        , note: "If you import 'putMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (readMVar x), rhs: readMVar x
        , note: "If you import 'readMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (swapMVar x y), rhs: swapMVar x y
        , note: "If you import 'swapMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (takeMVar x), rhs: takeMVar x
        , note: "If you import 'takeMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (tryPutMVar x y), rhs: tryPutMVar x y
        , note: "If you import 'tryPutMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (tryReadMVar x), rhs: tryReadMVar x
        , note: "If you import 'tryReadMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (tryTakeMVar x), rhs: tryTakeMVar x
        , note: "If you import 'tryTakeMVar' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (atomically x), rhs: atomically x
        , note: "If you import 'atomically' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (newTVarIO x), rhs: newTVarIO x
        , note: "If you import 'newTVarIO' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (readTVarIO x), rhs: readTVarIO x
        , note: "If you import 'readTVarIO' from Universum, it's already lifted" }

## IORef

- warn: { name: "liftIO is not needed", lhs: liftIO (newIORef x), rhs: newIORef x
        , note: "If you import 'newIORef' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (readIORef x), rhs: readIORef x
        , note: "If you import 'readIORef' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (writeIORef x y), rhs: writeIORef x y
        , note: "If you import 'writeIORef' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (modifyIORef x y), rhs: modifyIORef x y
        , note: "If you import 'modifyIORef' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: "liftIO (modifyIORef' x y)", rhs: "modifyIORef' x y"
        , note: "If you import 'modifyIORef'' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (atomicModifyIORef x y), rhs: atomicModifyIORef x y
        , note: "If you import 'atomicModifyIORef' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: "liftIO (atomicModifyIORef' x y)", rhs: "atomicModifyIORef' x y"
        , note: "If you import 'atomicModifyIORef'' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (atomicWriteIORef x y), rhs: atomicWriteIORef x y
        , note: "If you import 'atomicWriteIORef' from Universum, it's already lifted" }

## others

- warn: { name: "liftIO is not needed", lhs: liftIO getLine, rhs: getLine
        , note: "If you import 'getLine' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (readFile x), rhs: readFile x
        , note: "If you import 'readFile' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (writeFile x y), rhs: writeFile x y
        , note: "If you import 'writeFile' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (appendFile x y), rhs: appendFile x y
        , note: "If you import 'appendFile' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (openFile x y), rhs: openFile x y
        , note: "If you import 'openFile' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (exitWith x), rhs: exitWith x
        , note: "If you import 'exitWith' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO exitFailure, rhs: exitFailure
        , note: "If you import 'exitFailure' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO exitSuccess, rhs: exitSuccess
        , note: "If you import 'exitSuccess' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (die x), rhs: die x
        , note: "If you import 'die' from Universum, it's already lifted" }
- warn: { name: "liftIO is not needed", lhs: liftIO (stToIO x), rhs: stToIO x
        , note: "If you import 'stToIO' from Universum, it's already lifted" }
